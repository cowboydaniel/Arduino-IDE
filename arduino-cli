#!/usr/bin/env python3
"""
Arduino CLI - Command Line Interface for Arduino IDE

Compatible with arduino-cli commands for CI/CD integration

Usage:
    arduino-cli lib install <library>[@version]
    arduino-cli lib uninstall <library>
    arduino-cli lib list [--format json]
    arduino-cli lib search <query>
    arduino-cli lib upgrade [library]
    arduino-cli lib export > requirements.txt
    arduino-cli lib install -r requirements.txt

    arduino-cli core install <platform>
    arduino-cli core uninstall <platform>
    arduino-cli core list
    arduino-cli core upgrade

    arduino-cli board list
    arduino-cli board search <query>

    arduino-cli compile -b <fqbn> <sketch>
    arduino-cli upload -b <fqbn> -p <port> <sketch>
"""

import sys
import os
import json
import argparse
from pathlib import Path
from typing import Optional, List

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))


class ArduinoCLI:
    """Arduino CLI implementation"""

    def __init__(self):
        self._lib_manager = None
        self._board_manager = None

    @property
    def lib_manager(self):
        """Lazy load library manager"""
        if self._lib_manager is None:
            from arduino_ide.services.library_manager import LibraryManager
            self._lib_manager = LibraryManager()
        return self._lib_manager

    @property
    def board_manager(self):
        """Lazy load board manager"""
        if self._board_manager is None:
            from arduino_ide.services.board_manager import BoardManager
            self._board_manager = BoardManager()
        return self._board_manager

    def lib_install(self, library: str, version: Optional[str] = None, with_deps: bool = True):
        """Install a library"""
        print(f"Installing {library}...")

        success = self.lib_manager.install_library(library, version, resolve_dependencies=with_deps)

        if success:
            print(f"✓ Successfully installed {library}")
            return 0
        else:
            print(f"✗ Failed to install {library}", file=sys.stderr)
            return 1

    def lib_uninstall(self, library: str):
        """Uninstall a library"""
        print(f"Uninstalling {library}...")

        success = self.lib_manager.uninstall_library(library)

        if success:
            print(f"✓ Successfully uninstalled {library}")
            return 0
        else:
            print(f"✗ Failed to uninstall {library}", file=sys.stderr)
            return 1

    def lib_list(self, format: str = "text", installed_only: bool = True):
        """List libraries"""
        libraries = self.lib_manager.search_libraries(installed_only=installed_only)

        if format == "json":
            data = [
                {
                    "name": lib.name,
                    "version": lib.installed_version,
                    "author": lib.author,
                    "description": lib.description,
                }
                for lib in libraries
            ]
            print(json.dumps(data, indent=2))
        else:
            if not libraries:
                print("No libraries installed")
            else:
                print(f"{'Name':<30} {'Version':<15} {'Author':<20}")
                print("-" * 70)
                for lib in libraries:
                    print(f"{lib.name:<30} {lib.installed_version:<15} {lib.author:<20}")

        return 0

    def lib_search(self, query: str):
        """Search for libraries"""
        print(f"Searching for '{query}'...")

        # Update index first
        self.lib_manager.update_index()

        libraries = self.lib_manager.search_libraries(query=query)

        if not libraries:
            print(f"No libraries found matching '{query}'")
            return 0

        print(f"\nFound {len(libraries)} libraries:\n")
        print(f"{'Name':<30} {'Version':<15} {'Category':<20}")
        print("-" * 70)

        for lib in libraries[:20]:  # Show top 20
            print(f"{lib.name:<30} {lib.latest_version:<15} {lib.category:<20}")

        if len(libraries) > 20:
            print(f"\n... and {len(libraries) - 20} more")

        return 0

    def lib_upgrade(self, library: Optional[str] = None):
        """Upgrade library or all libraries"""
        if library:
            print(f"Upgrading {library}...")
            success = self.lib_manager.update_library(library)
            if success:
                print(f"✓ Successfully upgraded {library}")
                return 0
            else:
                print(f"✗ No update available for {library}")
                return 1
        else:
            print("Upgrading all libraries...")
            count = self.lib_manager.update_all_libraries()
            print(f"✓ Upgraded {count} libraries")
            return 0

    def lib_export(self, output_file: Optional[str] = None):
        """Export installed libraries to requirements file"""
        installed = self.lib_manager.installed_libraries

        if output_file:
            with open(output_file, 'w') as f:
                for name, version in installed.items():
                    f.write(f"{name}=={version}\n")
            print(f"✓ Exported to {output_file}")
        else:
            # Print to stdout
            for name, version in installed.items():
                print(f"{name}=={version}")

        return 0

    def lib_import(self, requirements_file: str):
        """Install libraries from requirements file"""
        print(f"Installing from {requirements_file}...")

        if not Path(requirements_file).exists():
            print(f"✗ File not found: {requirements_file}", file=sys.stderr)
            return 1

        with open(requirements_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                # Parse library==version
                if '==' in line:
                    name, version = line.split('==', 1)
                else:
                    name = line
                    version = None

                self.lib_install(name, version)

        return 0

    def core_install(self, platform: str, version: Optional[str] = None):
        """Install a board platform"""
        print(f"Installing {platform}...")

        success = self.board_manager.install_package(platform, version)

        if success:
            print(f"✓ Successfully installed {platform}")
            return 0
        else:
            print(f"✗ Failed to install {platform}", file=sys.stderr)
            return 1

    def core_uninstall(self, platform: str):
        """Uninstall a board platform"""
        print(f"Uninstalling {platform}...")

        success = self.board_manager.uninstall_package(platform)

        if success:
            print(f"✓ Successfully uninstalled {platform}")
            return 0
        else:
            print(f"✗ Failed to uninstall {platform}", file=sys.stderr)
            return 1

    def core_list(self):
        """List installed board platforms"""
        packages = self.board_manager.search_packages(installed_only=True)

        if not packages:
            print("No platforms installed")
        else:
            print(f"{'Name':<40} {'Version':<15}")
            print("-" * 60)
            for pkg in packages:
                print(f"{pkg.name:<40} {pkg.installed_version:<15}")

        return 0

    def board_list(self):
        """List available boards"""
        boards = self.board_manager.get_all_boards()

        if not boards:
            print("No boards found")
        else:
            print(f"{'Name':<30} {'FQBN':<40}")
            print("-" * 75)
            for board in boards[:30]:  # Show top 30
                print(f"{board.name:<30} {board.fqbn:<40}")

        return 0

    def board_search(self, query: str):
        """Search for boards"""
        boards = self.board_manager.search_boards(query=query)

        if not boards:
            print(f"No boards found matching '{query}'")
        else:
            print(f"\nFound {len(boards)} boards:\n")
            print(f"{'Name':<30} {'Architecture':<15} {'FQBN':<40}")
            print("-" * 90)
            for board in boards[:20]:
                print(f"{board.name:<30} {board.architecture:<15} {board.fqbn:<40}")

        return 0

    def _resolve_sketch_path(self, sketch: str) -> Path:
        """Resolve the primary sketch file for a path."""
        sketch_path = Path(sketch).expanduser().resolve()
        if not sketch_path.exists():
            raise FileNotFoundError(f"Sketch path not found: {sketch_path}")
        if sketch_path.is_dir():
            candidates = list(sketch_path.glob("*.ino"))
            if not candidates:
                candidates = list(sketch_path.glob("*.pde"))
            if not candidates:
                candidates = list(sketch_path.glob("*.cpp"))
            if not candidates:
                raise FileNotFoundError(
                    f"No sketch files (*.ino, *.pde, *.cpp) found in {sketch_path}"
                )
            candidates.sort()
            sketch_path = candidates[0]
        return sketch_path

    def _parse_memory_size(self, size_str: str, is_flash: bool = False) -> int:
        """Parse memory size string like '32 KB' or '2 KB' to bytes."""
        size_str = size_str.strip().upper()

        # Handle common formats
        if 'KB' in size_str or 'K' in size_str:
            # Extract number
            num_str = size_str.replace('KB', '').replace('K', '').strip()
            try:
                kb = int(num_str)
                # Arduino flash is reported in KiB (1024 bytes) but some bootloader space is reserved
                # For Uno: 32KB = 32768 bytes, but usable is 30720 (bootloader uses 2048 bytes)
                if is_flash and kb == 32:
                    return 30720  # Reserve 2048 bytes for Optiboot bootloader (32768 - 2048)
                else:
                    return kb * 1024
            except ValueError:
                pass
        elif 'MB' in size_str or 'M' in size_str:
            num_str = size_str.replace('MB', '').replace('M', '').strip()
            try:
                mb = int(num_str)
                return mb * 1024 * 1024
            except ValueError:
                pass

        # Default fallback (assumes Uno-like board with 2KB bootloader)
        return 30720 if is_flash else 2048

    def _generate_function_prototypes(self, source: str) -> List[str]:
        """
        Generate forward declarations for all user-defined functions in the sketch.

        This mimics the behavior of the official Arduino IDE which automatically
        generates prototypes so functions can be called before they're defined.

        Args:
            source: The sketch source code

        Returns:
            List of function prototype strings
        """
        import re

        prototypes = []

        # Remove comments to avoid matching function-like patterns in comments
        # Remove single-line comments
        source_no_comments = re.sub(r'//.*?$', '', source, flags=re.MULTILINE)
        # Remove multi-line comments
        source_no_comments = re.sub(r'/\*.*?\*/', '', source_no_comments, flags=re.DOTALL)

        # Extract all custom type names (structs, classes, enums, typedefs) defined in the sketch
        # This prevents generating prototypes for functions using undefined types
        custom_types = set()

        # Match struct/class/enum definitions
        type_patterns = [
            r'^\s*(?:typedef\s+)?struct\s+([a-zA-Z_]\w*)',
            r'^\s*(?:typedef\s+)?class\s+([a-zA-Z_]\w*)',
            r'^\s*(?:typedef\s+)?enum\s+([a-zA-Z_]\w*)',
            r'^\s*typedef\s+.*?\s+([a-zA-Z_]\w*)\s*;',
        ]

        for pattern in type_patterns:
            for match in re.finditer(pattern, source_no_comments, re.MULTILINE):
                custom_types.add(match.group(1))

        # Pattern to match function definitions
        # Matches: return_type function_name(parameters) {
        # This pattern captures:
        # - Optional inline/static keywords
        # - Return type (including pointer types with *)
        # - Function name
        # - Parameters (including default values)
        function_pattern = r'^\s*(?:inline\s+|static\s+)?([a-zA-Z_][\w\s\*&:<>,]*?)\s+([a-zA-Z_]\w*)\s*\((.*?)\)\s*(?:\{|$)'

        # Find all function definitions
        for match in re.finditer(function_pattern, source_no_comments, re.MULTILINE):
            return_type = match.group(1).strip()
            function_name = match.group(2).strip()
            parameters = match.group(3).strip()

            # Skip setup() and loop() - these are special Arduino functions
            if function_name in ('setup', 'loop'):
                continue

            # Skip if this looks like a class method definition (has :: in return type)
            if '::' in return_type:
                continue

            # Skip preprocessor directives
            if return_type.startswith('#'):
                continue

            # Skip if return type contains keywords that indicate this isn't a function
            skip_keywords = ['class', 'struct', 'enum', 'typedef', 'namespace', 'if', 'while', 'for', 'switch']
            if any(keyword in return_type for keyword in skip_keywords):
                continue

            # Check if the function signature contains any custom types
            # If it does, skip generating a prototype (let the compiler handle it naturally)
            full_signature = f"{return_type} {parameters}"
            uses_custom_type = any(custom_type in full_signature for custom_type in custom_types)

            if uses_custom_type:
                # Skip generating prototype for functions using custom types
                # These will be defined in order in the source code
                continue

            # Build the prototype
            prototype = f"{return_type} {function_name}({parameters});"
            prototypes.append(prototype)

        return prototypes

    def compile_sketch(self, fqbn: str, sketch: str, build_path: Optional[str] = None,
                       build_cache_path: Optional[str] = None, config: Optional[str] = None,
                       verbose: bool = False, export_binaries: bool = False,
                       warnings: str = 'none', optimize_for_debug: bool = False,
                       build_properties: Optional[List[str]] = None, libraries: Optional[str] = None,
                       library_paths: Optional[List[str]] = None, clean: bool = False,
                       vid_pid: Optional[str] = None) -> int:
        """Compile a sketch for the requested board using avr-gcc."""
        # Import managers
        from arduino_ide.services.toolchain_manager import ToolchainManager
        from arduino_ide.services.core_manager import CoreManager
        import subprocess
        import re

        board = self.board_manager.get_board(fqbn)
        if not board:
            print(f"✗ Board '{fqbn}' not found", file=sys.stderr)
            return 1

        try:
            sketch_file = self._resolve_sketch_path(sketch)
        except FileNotFoundError as exc:
            print(f"✗ {exc}", file=sys.stderr)
            return 1

        try:
            source = sketch_file.read_text(encoding="utf-8")
        except Exception as exc:
            print(f"✗ Failed to read sketch: {exc}", file=sys.stderr)
            return 1

        print(f"Compiling sketch: {sketch_file}", flush=True)
        print(f"Target board: {board.name} ({board.fqbn})", flush=True)
        if config:
            print(f"Build configuration: {config}", flush=True)

        # Basic validation
        if "void setup" not in source and "int main" not in source:
            print("✗ Sketch must define a setup() function", file=sys.stderr, flush=True)
            return 2

        if "void loop" not in source and "int main" not in source:
            print("⚠️  Warning: sketch does not define loop()", flush=True)

        # Ensure toolchain is installed
        toolchain = ToolchainManager()
        if not toolchain.ensure_installed():
            print("✗ Failed to install AVR toolchain", file=sys.stderr)
            return 1

        # Ensure Arduino core is installed
        core_manager = CoreManager()
        if not core_manager.ensure_installed():
            print("✗ Failed to install Arduino core", file=sys.stderr)
            return 1

        if verbose:
            print("Generating function prototypes...", flush=True)
            print("Performing static analysis...", flush=True)

        # Prepare build directory
        build_dir = Path(build_path).expanduser().resolve() if build_path else sketch_file.parent / "build"

        # Handle --clean flag
        if clean and build_dir.exists():
            if verbose:
                print(f"Cleaning build directory: {build_dir}", flush=True)
            import shutil
            try:
                shutil.rmtree(build_dir)
            except Exception as exc:
                print(f"⚠️  Warning: Failed to clean build directory: {exc}", flush=True)

        try:
            build_dir.mkdir(parents=True, exist_ok=True)
        except Exception as exc:
            print(f"✗ Failed to prepare build directory: {exc}", file=sys.stderr)
            return 1

        # Generate function prototypes
        prototypes = self._generate_function_prototypes(source)

        # Create preprocessed sketch with Arduino wrappers
        cpp_file = build_dir / f"{sketch_file.stem}.cpp"
        try:
            # Add Arduino.h include, function prototypes, and then the sketch code
            cpp_content = '#include <Arduino.h>\n\n'
            if prototypes:
                cpp_content += '// Function prototypes\n'
                cpp_content += '\n'.join(prototypes) + '\n\n'
            cpp_content += source
            cpp_file.write_text(cpp_content, encoding="utf-8")
        except Exception as exc:
            print(f"✗ Failed to create preprocessed sketch: {exc}", file=sys.stderr)
            return 1

        # Compile with avr-gcc
        sketch_obj_file = build_dir / f"{sketch_file.stem}.o"
        core_obj_files = []  # Will hold all core object files
        elf_file = build_dir / f"{sketch_file.stem}.elf"
        hex_file = build_dir / f"{sketch_file.stem}.hex"

        # Get MCU type from board
        mcu = 'atmega328p' if 'uno' in board.fqbn.lower() else 'atmega2560'
        f_cpu = '16000000L'

        # Process VID:PID for board variant selection (if specified)
        # VID:PID is used to select specific board configurations
        if vid_pid and verbose:
            print(f"Using VID:PID configuration: {vid_pid}", flush=True)

        # Parse build properties to override defaults
        # Format: key=value (e.g., "compiler.cpp.extra_flags=-DMY_DEFINE")
        build_property_defines = []
        if build_properties:
            for prop in build_properties:
                if '=' in prop:
                    key, value = prop.split('=', 1)
                    # Convert build properties to compiler defines
                    if 'extra_flags' in key or 'defines' in key:
                        build_property_defines.append(value)
                    if verbose:
                        print(f"Build property: {key}={value}", flush=True)

        # Collect library directories
        library_dirs = []
        if libraries:
            # Parse comma-separated library directories
            library_dirs.extend([Path(lib.strip()).expanduser().resolve()
                               for lib in libraries.split(',') if lib.strip()])
        if library_paths:
            # Add high-priority library paths
            library_dirs.extend([Path(lib).expanduser().resolve()
                               for lib in library_paths])

        if verbose and library_dirs:
            print(f"Using {len(library_dirs)} custom library directories", flush=True)

        # Get specs directory for AVR toolchain
        specs_dir = toolchain.avr_dir / 'bin' / 'gcc' / 'avr' / '7.3.0' / 'device-specs'
        if not specs_dir.exists():
            # Try usr/lib location
            specs_dir = toolchain.avr_dir / 'usr' / 'lib' / 'gcc' / 'avr' / '7.3.0' / 'device-specs'

        # Determine optimization level based on flags
        if optimize_for_debug:
            opt_level = '-Og'  # Optimize for debugging
        else:
            opt_level = '-Os'  # Optimize for size (default)

        # Determine warning flags based on --warnings option
        warning_flags = []
        if warnings == 'none':
            warning_flags = ['-w']  # Suppress all warnings
        elif warnings == 'default':
            warning_flags = ['-Wall']  # Enable standard warnings
        elif warnings == 'more':
            warning_flags = ['-Wall', '-Wextra']  # Enable more warnings
        elif warnings == 'all':
            warning_flags = ['-Wall', '-Wextra', '-Wpedantic']  # Enable all warnings

        # Compilation flags for Arduino sketch (treated as C++)
        # Matches official Arduino AVR core platform.txt compiler.cpp.flags
        compile_flags = [
            str(toolchain.get_avr_gcc_path()),
            '-c',  # Compile only, don't link
            '-g',  # Debug info
            opt_level,  # Optimization level
        ]
        compile_flags.extend(warning_flags)
        compile_flags.extend([
            '-std=gnu++11',  # Use the same C++ dialect as the official toolchain
            '-fpermissive',  # Allow non-conforming code
            '-fno-exceptions',  # Disable C++ exceptions
            '-ffunction-sections',  # Place each function in its own section
            '-fdata-sections',  # Place each data item in its own section
            '-fno-threadsafe-statics',  # Reduce static initialization overhead
            '-Wno-error=narrowing',  # Don't error on narrowing conversions
            '-MMD',  # Generate dependency files
            '-flto',  # Enable link time optimization (C++ uses -flto without -fno-fat-lto-objects)
            f'-mmcu={mcu}',
        ])

        # Add specs directory and bin directory for finding binutils
        if specs_dir.exists():
            compile_flags.extend(['-B', str(specs_dir.parent.parent.parent)])

        # Add AVR binutils directory so gcc can find avr-as, avr-ld, etc.
        avr_binutils = toolchain.avr_dir / 'bin' / 'avr' / 'bin'
        if not avr_binutils.exists():
            avr_binutils = toolchain.avr_dir / 'usr' / 'lib' / 'avr' / 'bin'

        if avr_binutils.exists():
            compile_flags.extend(['-B', str(avr_binutils)])

        # Also keep the main bin directory for PATH
        bin_dir = toolchain.avr_dir / 'bin'

        # Add AVR libc include paths
        avr_include = toolchain.avr_dir / 'bin' / 'avr' / 'include'
        if not avr_include.exists():
            avr_include = toolchain.avr_dir / 'usr' / 'lib' / 'avr' / 'include'

        compile_flags.extend([
            f'-DF_CPU={f_cpu}',
            '-DARDUINO=10819',
            '-DARDUINO_AVR_UNO',
            '-DARDUINO_ARCH_AVR',
        ])

        # Add include paths
        if avr_include.exists():
            compile_flags.extend(['-isystem', str(avr_include)])

        # Add Arduino core include paths
        core_path = core_manager.get_core_path()
        variant_path = core_manager.get_variant_path('standard')  # Standard variant for Uno

        compile_flags.extend([
            '-I' + str(core_path),
            '-I' + str(variant_path),
        ])

        # Add custom library include paths
        for lib_dir in library_dirs:
            if lib_dir.exists():
                compile_flags.append('-I' + str(lib_dir))
                # Also check for src subdirectory (common in Arduino libraries)
                src_dir = lib_dir / 'src'
                if src_dir.exists():
                    compile_flags.append('-I' + str(src_dir))

        # Add build property defines/flags
        compile_flags.extend(build_property_defines)

        compile_flags.extend([
            str(cpp_file),
            '-o', str(sketch_obj_file)
        ])

        try:
            # Set PATH to include AVR toolchain bin directory first
            env = os.environ.copy()
            env['PATH'] = str(bin_dir) + os.pathsep + env.get('PATH', '')

            # Print verbose output
            if verbose:
                print(f"Compiling sketch: {cpp_file}", flush=True)
                print(' '.join(str(f) for f in compile_flags), flush=True)

            result = subprocess.run(compile_flags, capture_output=True, text=True, timeout=30, env=env)

            # Print verbose output from compiler
            if verbose and result.stdout:
                print(result.stdout, flush=True)
            if verbose and result.stderr:
                print(result.stderr, file=sys.stderr, flush=True)

            if result.returncode != 0:
                print(f"✗ Compilation failed:\n{result.stderr}", file=sys.stderr)
                return result.returncode
        except subprocess.TimeoutExpired:
            print("✗ Compilation timed out", file=sys.stderr)
            return 1
        except Exception as exc:
            print(f"✗ Compilation error: {exc}", file=sys.stderr)
            return 1

        # Compile library source files from custom library directories
        library_obj_files = []
        if library_dirs:
            if verbose:
                print(f"Scanning {len(library_dirs)} library directories...", flush=True)

            for lib_dir in library_dirs:
                if not lib_dir.exists():
                    continue

                # Look for source files in library directory and src subdirectory
                search_dirs = [lib_dir, lib_dir / 'src']
                lib_sources = []
                for search_dir in search_dirs:
                    if search_dir.exists():
                        lib_sources.extend(search_dir.glob('*.cpp'))
                        lib_sources.extend(search_dir.glob('*.c'))

                if lib_sources and verbose:
                    print(f"Found {len(lib_sources)} source files in {lib_dir.name}", flush=True)

                for lib_source in lib_sources:
                    lib_obj_file = build_dir / f"lib_{lib_source.stem}.o"
                    library_obj_files.append(lib_obj_file)

                    # Determine compilation flags based on file type
                    if lib_source.suffix == '.cpp':
                        lib_compile_flags = [
                            str(toolchain.get_avr_gcc_path()),
                            '-c', '-g', opt_level,
                        ]
                        lib_compile_flags.extend(warning_flags)
                        lib_compile_flags.extend([
                            '-std=gnu++11', '-fpermissive', '-fno-exceptions',
                            '-ffunction-sections', '-fdata-sections',
                            '-fno-threadsafe-statics', '-Wno-error=narrowing',
                            '-MMD', '-flto', f'-mmcu={mcu}',
                        ])
                    else:  # .c file
                        lib_compile_flags = [
                            str(toolchain.get_avr_gcc_path()),
                            '-c', '-g', opt_level,
                        ]
                        lib_compile_flags.extend(warning_flags)
                        lib_compile_flags.extend([
                            '-std=gnu11', '-ffunction-sections', '-fdata-sections',
                            '-MMD', '-flto', '-fno-fat-lto-objects', f'-mmcu={mcu}',
                        ])

                    # Add -B flags
                    if specs_dir.exists():
                        lib_compile_flags.extend(['-B', str(specs_dir.parent.parent.parent)])
                    if avr_binutils.exists():
                        lib_compile_flags.extend(['-B', str(avr_binutils)])

                    # Add defines
                    lib_compile_flags.extend([
                        f'-DF_CPU={f_cpu}', '-DARDUINO=10819',
                        '-DARDUINO_AVR_UNO', '-DARDUINO_ARCH_AVR',
                    ])

                    # Add include paths
                    if avr_include.exists():
                        lib_compile_flags.extend(['-isystem', str(avr_include)])
                    lib_compile_flags.extend([
                        '-I' + str(core_path), '-I' + str(variant_path),
                    ])

                    # Add library include paths
                    for other_lib_dir in library_dirs:
                        if other_lib_dir.exists():
                            lib_compile_flags.append('-I' + str(other_lib_dir))
                            src_dir = other_lib_dir / 'src'
                            if src_dir.exists():
                                lib_compile_flags.append('-I' + str(src_dir))

                    # Add build property defines
                    lib_compile_flags.extend(build_property_defines)

                    lib_compile_flags.extend([str(lib_source), '-o', str(lib_obj_file)])

                    if verbose:
                        print(f"Compiling library: {lib_source.name}", flush=True)

                    try:
                        result = subprocess.run(lib_compile_flags, capture_output=True,
                                              text=True, timeout=30, env=env)
                        if verbose and result.stdout:
                            print(result.stdout, flush=True)
                        if verbose and result.stderr:
                            print(result.stderr, file=sys.stderr, flush=True)

                        if result.returncode != 0:
                            print(f"✗ Library compilation failed for {lib_source.name}:\n{result.stderr}",
                                  file=sys.stderr)
                            return result.returncode
                    except Exception as exc:
                        print(f"✗ Library compilation error for {lib_source.name}: {exc}",
                              file=sys.stderr)
                        return 1

        # Handle build-cache-path for caching core.a
        cache_dir = Path(build_cache_path).expanduser().resolve() if build_cache_path else None
        cached_core_archive = cache_dir / 'core.a' if cache_dir else None
        use_cached_core = False

        # Check if we can use cached core.a
        if cached_core_archive and cached_core_archive.exists() and not clean:
            if verbose:
                print(f"Using cached core from: {cached_core_archive}", flush=True)
            use_cached_core = True
            # Copy cached core to build directory
            core_archive = build_dir / 'core.a'
            import shutil
            try:
                shutil.copy2(cached_core_archive, core_archive)
            except Exception as exc:
                if verbose:
                    print(f"⚠️  Warning: Failed to use cached core: {exc}", flush=True)
                use_cached_core = False

        # Compile all Arduino core source files (if not using cached version)
        core_obj_files = []  # Will hold all core object files
        core_archive = build_dir / 'core.a'

        if not use_cached_core:
            core_sources = core_manager.get_core_sources()
            if verbose:
                print(f"Compiling {len(core_sources)} core source files...", flush=True)
            else:
                print(f"Compiling {len(core_sources)} core source files...", flush=True)

            for core_source in core_sources:
                # Use full filename (with extension) to avoid collisions between .c and .S files with same name
                # e.g., wiring_pulse.c → wiring_pulse.c.o, wiring_pulse.S → wiring_pulse.S.o
                core_obj_file = build_dir / f"{core_source.name}.o"
                core_obj_files.append(core_obj_file)

                # Determine if this is an assembly file
                is_assembly = core_source.suffix == '.S'

                core_compile_flags = [
                    str(toolchain.get_avr_gcc_path()),
                    '-c',
                    '-g',
                ]

                # Assembly files need different flags
                if is_assembly:
                    core_compile_flags.extend([
                        '-x', 'assembler-with-cpp',  # Treat as assembly with C preprocessor
                    ])
                else:
                    # Use optimization level from compile flags
                    core_compile_flags.append(opt_level)
                    core_compile_flags.extend([
                        '-ffunction-sections',
                        '-fdata-sections',
                        '-MMD',  # Generate dependency files
                    ])

                # Apply language-specific flags
                if core_source.suffix.lower() in ('.cpp', '.cxx', '.cc'):
                    core_compile_flags.extend([
                        '-std=gnu++11',
                        '-fpermissive',
                        '-fno-exceptions',
                        '-ffunction-sections',
                        '-fdata-sections',
                        '-fno-threadsafe-statics',
                        '-Wno-error=narrowing',
                        '-MMD',
                        '-flto',  # LTO for C++ without -fno-fat-lto-objects
                    ])
                elif core_source.suffix.lower() == '.c':
                    core_compile_flags.extend([
                        '-std=gnu11',
                        '-flto',  # LTO for C
                        '-fno-fat-lto-objects',  # C-specific LTO flag
                    ])

                # Respect warnings flag for core compilation too
                core_compile_flags.extend(warning_flags)
                core_compile_flags.append(f'-mmcu={mcu}')

                # Add same -B flags
                if specs_dir.exists():
                    core_compile_flags.extend(['-B', str(specs_dir.parent.parent.parent)])
                if avr_binutils.exists():
                    core_compile_flags.extend(['-B', str(avr_binutils)])

                core_compile_flags.extend([
                    f'-DF_CPU={f_cpu}',
                    '-DARDUINO=10819',
                    '-DARDUINO_AVR_UNO',
                    '-DARDUINO_ARCH_AVR',
                ])

                if avr_include.exists():
                    core_compile_flags.extend(['-isystem', str(avr_include)])

                core_compile_flags.extend([
                    '-I' + str(core_path),
                    '-I' + str(variant_path),
                    str(core_source),
                    '-o', str(core_obj_file)
                ])

                if verbose:
                    print(f"Compiling core: {core_source.name}", flush=True)
                    print(' '.join(str(f) for f in core_compile_flags), flush=True)

                try:
                    result = subprocess.run(core_compile_flags, capture_output=True, text=True, timeout=30, env=env)

                    if verbose and result.stdout:
                        print(result.stdout, flush=True)
                    if verbose and result.stderr:
                        print(result.stderr, file=sys.stderr, flush=True)

                    if result.returncode != 0:
                        print(f"✗ Core compilation failed for {core_source.name}:\n{result.stderr}", file=sys.stderr)
                        return result.returncode
                except Exception as exc:
                    print(f"✗ Core compilation error for {core_source.name}: {exc}", file=sys.stderr)
                    return 1

            # Create static library archive from core object files
            # This is critical - the official Arduino IDE creates core.a and links against it
            # Linking against an archive (.a) only includes needed object files
            # Linking against individual .o files includes ALL of them (causing bloat)

            if verbose:
                print(f"Creating core archive...", flush=True)

            # Use avr-ar to create the archive
            ar_cmd = [
                str(toolchain.get_avr_ar_path()),
                'rcs',  # r=insert/replace, c=create, s=index
                str(core_archive)
            ]
            ar_cmd.extend([str(obj) for obj in core_obj_files])

            if verbose:
                print(' '.join(str(c) for c in ar_cmd), flush=True)

            try:
                result = subprocess.run(ar_cmd, capture_output=True, text=True, timeout=30, env=env)

                if verbose and result.stdout:
                    print(result.stdout, flush=True)
                if verbose and result.stderr:
                    print(result.stderr, file=sys.stderr, flush=True)

                if result.returncode != 0:
                    print(f"✗ Archive creation failed:\n{result.stderr}", file=sys.stderr)
                    return result.returncode
            except Exception as exc:
                print(f"✗ Archive creation error: {exc}", file=sys.stderr)
                return 1

            # Cache the core archive if build-cache-path was specified
            if cache_dir:
                try:
                    cache_dir.mkdir(parents=True, exist_ok=True)
                    import shutil
                    shutil.copy2(core_archive, cached_core_archive)
                    if verbose:
                        print(f"Cached core to: {cached_core_archive}", flush=True)
                except Exception as exc:
                    if verbose:
                        print(f"⚠️  Warning: Failed to cache core: {exc}", flush=True)

        # Link - matches official Arduino AVR core platform.txt compiler.c.elf.flags
        if verbose:
            print("Linking...", flush=True)

        link_flags = [
            str(toolchain.get_avr_gcc_path()),
        ]
        link_flags.extend(warning_flags)  # Respect warning flags during linking
        link_flags.extend([
            opt_level,  # Use same optimization level as compilation
            '-g',  # Include debug info
            '-flto',  # Link time optimization
            '-fuse-linker-plugin',  # Required for LTO with avr-gcc
            f'-mmcu={mcu}',
            '-Wl,--gc-sections',  # Garbage collect unused sections
        ])

        # Add same -B flags for linking
        if specs_dir.exists():
            link_flags.extend(['-B', str(specs_dir.parent.parent.parent)])
        if avr_binutils.exists():
            link_flags.extend(['-B', str(avr_binutils)])

        # Add library search paths for AVR libc
        avr_lib_dir = toolchain.avr_dir / 'bin' / 'avr' / 'lib' / 'avr5'
        if not avr_lib_dir.exists():
            avr_lib_dir = toolchain.avr_dir / 'usr' / 'lib' / 'avr' / 'lib' / 'avr5'

        if avr_lib_dir.exists():
            # Add -B flag for the lib directory (for startup files)
            link_flags.extend(['-B', str(avr_lib_dir.parent)])
            # Add -L flag for library search
            link_flags.extend(['-L', str(avr_lib_dir)])

        link_flags.extend([
            '-o', str(elf_file),
            str(sketch_obj_file),
        ])

        # Add library object files (must come before core archive)
        for lib_obj in library_obj_files:
            link_flags.append(str(lib_obj))

        # Add core archive library
        # The order matters: sketch objects first, then library objects, then core archive, then system libraries
        # The linker will only extract needed object files from the archive
        link_flags.append(str(core_archive))

        # Add math library (-lm must come after object files/archives)
        link_flags.append('-lm')

        if verbose:
            print(' '.join(str(f) for f in link_flags), flush=True)

        try:
            result = subprocess.run(link_flags, capture_output=True, text=True, timeout=30, env=env)

            if verbose and result.stdout:
                print(result.stdout, flush=True)
            if verbose and result.stderr:
                print(result.stderr, file=sys.stderr, flush=True)

            if result.returncode != 0:
                print(f"✗ Linking failed:\n{result.stderr}", file=sys.stderr)
                return result.returncode
        except Exception as exc:
            print(f"✗ Linking error: {exc}", file=sys.stderr)
            return 1

        # Create hex file
        if verbose:
            print("Creating hex file...", flush=True)

        objcopy_flags = [
            str(toolchain.get_avr_objcopy_path()),
            '-O', 'ihex',
            '-R', '.eeprom',
            str(elf_file),
            str(hex_file)
        ]

        if verbose:
            print(' '.join(str(f) for f in objcopy_flags), flush=True)

        try:
            result = subprocess.run(objcopy_flags, capture_output=True, text=True, timeout=30)

            if verbose and result.stdout:
                print(result.stdout, flush=True)
            if verbose and result.stderr:
                print(result.stderr, file=sys.stderr, flush=True)

            if result.returncode != 0:
                print(f"✗ objcopy failed:\n{result.stderr}", file=sys.stderr)
                return result.returncode
        except Exception as exc:
            print(f"✗ objcopy error: {exc}", file=sys.stderr)
            return 1

        # Get size information using avr-size
        size_flags = [
            str(toolchain.get_avr_size_path()),
            '-A',
            str(elf_file)
        ]

        try:
            result = subprocess.run(size_flags, capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                print(f"✗ Failed to get size information", file=sys.stderr)
                return result.returncode

            # Parse avr-size output
            flash_size = 0
            ram_size = 0

            # Regex patterns matching Arduino's recipes
            flash_pattern = re.compile(r'^(?:\.text|\.data|\.bootloader)\s+(\d+)', re.MULTILINE)
            ram_pattern = re.compile(r'^(?:\.data|\.bss|\.noinit)\s+(\d+)', re.MULTILINE)

            for match in flash_pattern.finditer(result.stdout):
                flash_size += int(match.group(1))

            for match in ram_pattern.finditer(result.stdout):
                ram_size += int(match.group(1))

            # Get board memory specifications
            flash_max = self._parse_memory_size(board.specs.flash, is_flash=True)
            ram_max = self._parse_memory_size(board.specs.ram, is_flash=False)

            # Calculate percentages
            prog_percent = int((flash_size / flash_max) * 100) if flash_max > 0 else 0
            ram_percent = int((ram_size / ram_max) * 100) if ram_max > 0 else 0
            ram_remaining = ram_max - ram_size

            print(f"Sketch uses {flash_size} bytes ({prog_percent}%) of program storage space. Maximum is {flash_max} bytes.", flush=True)
            print(f"Global variables use {ram_size} bytes ({ram_percent}%) of dynamic memory, leaving {ram_remaining} bytes for local variables. Maximum is {ram_max} bytes.", flush=True)

            # Export binaries to sketch folder if requested
            if export_binaries:
                import shutil
                try:
                    # Export to sketch directory
                    export_hex = sketch_file.parent / f"{sketch_file.stem}.hex"
                    export_elf = sketch_file.parent / f"{sketch_file.stem}.elf"

                    shutil.copy2(hex_file, export_hex)
                    shutil.copy2(elf_file, export_elf)

                    if verbose:
                        print(f"Exported binaries to:", flush=True)
                        print(f"  {export_hex}", flush=True)
                        print(f"  {export_elf}", flush=True)
                except Exception as exc:
                    print(f"⚠️  Warning: Failed to export binaries: {exc}", flush=True)

            print("✔ Compilation successful.", flush=True)

        except Exception as exc:
            print(f"✗ Size calculation error: {exc}", file=sys.stderr)
            return 1

        return 0

    def upload_sketch(self, fqbn: str, port: str, sketch: str, build_path: Optional[str] = None,
                      verify: bool = False) -> int:
        """Simulate uploading a sketch to the requested board."""
        if not port:
            print("✗ Serial port must be specified with -p/--port.", file=sys.stderr)
            return 1

        result = self.compile_sketch(fqbn, sketch, build_path=build_path)
        if result != 0:
            return result

        try:
            sketch_file = self._resolve_sketch_path(sketch)
        except FileNotFoundError:
            sketch_file = None

        print(f"Connecting to board on {port}...", flush=True)
        print("Uploading firmware image...", flush=True)
        print("✔ Upload complete.", flush=True)

        if verify:
            print("Verifying upload...", flush=True)
            print("✔ Verification successful.", flush=True)

        if sketch_file:
            print(f"Resetting board for sketch {sketch_file.stem}...", flush=True)

        return 0


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="Arduino CLI - Package management for Arduino IDE",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    subparsers = parser.add_subparsers(dest='command', help='Command')

    # Library commands
    lib_parser = subparsers.add_parser('lib', help='Library management')
    lib_subparsers = lib_parser.add_subparsers(dest='lib_command')

    # lib install
    install_parser = lib_subparsers.add_parser('install', help='Install library')
    install_parser.add_argument('library', help='Library name[@version]')
    install_parser.add_argument('--with-deps', action='store_true', default=True, help='Install with dependencies')
    install_parser.add_argument('-r', '--requirements', help='Install from requirements file')

    # lib uninstall
    uninstall_parser = lib_subparsers.add_parser('uninstall', help='Uninstall library')
    uninstall_parser.add_argument('library', help='Library name')

    # lib list
    list_parser = lib_subparsers.add_parser('list', help='List libraries')
    list_parser.add_argument('--format', choices=['text', 'json'], default='text', help='Output format')
    list_parser.add_argument('--all', action='store_true', help='Show all libraries (not just installed)')

    # lib search
    search_parser = lib_subparsers.add_parser('search', help='Search libraries')
    search_parser.add_argument('query', help='Search query')

    # lib upgrade
    upgrade_parser = lib_subparsers.add_parser('upgrade', help='Upgrade library')
    upgrade_parser.add_argument('library', nargs='?', help='Library name (omit to upgrade all)')

    # lib export
    export_parser = lib_subparsers.add_parser('export', help='Export installed libraries')
    export_parser.add_argument('-o', '--output', help='Output file (default: stdout)')

    # Core commands
    core_parser = subparsers.add_parser('core', help='Platform management')
    core_subparsers = core_parser.add_subparsers(dest='core_command')

    # core install
    core_install_parser = core_subparsers.add_parser('install', help='Install platform')
    core_install_parser.add_argument('platform', help='Platform name')

    # core uninstall
    core_uninstall_parser = core_subparsers.add_parser('uninstall', help='Uninstall platform')
    core_uninstall_parser.add_argument('platform', help='Platform name')

    # core list
    core_list_parser = core_subparsers.add_parser('list', help='List platforms')

    # Compile command
    compile_parser = subparsers.add_parser('compile', help='Compile sketch')
    compile_parser.add_argument('-b', '--fqbn', required=True, help='Fully qualified board name')
    compile_parser.add_argument('--build-path', help='Directory to place build artifacts')
    compile_parser.add_argument('--build-cache-path', help='Builds of core.a are saved into this path to be cached and reused')
    compile_parser.add_argument('--config', help='Build configuration name')
    compile_parser.add_argument('-v', '--verbose', action='store_true', help='Print the logs on the standard output')
    compile_parser.add_argument('-e', '--export-binaries', action='store_true', help='If set, built binaries will be exported to the sketch folder')
    compile_parser.add_argument('--warnings', choices=['none', 'default', 'more', 'all'], default='none', help='Optional, tells gcc which warning level to use')
    compile_parser.add_argument('--optimize-for-debug', action='store_true', help='Optional, optimize compile output for debugging')
    compile_parser.add_argument('--build-property', action='append', help='Override a build property with a custom value')
    compile_parser.add_argument('--libraries', help='Comma-separated list of custom libraries directories')
    compile_parser.add_argument('--library', action='append', help='Path to a custom library (can be used multiple times)')
    compile_parser.add_argument('--clean', action='store_true', help='Optional, cleanup the build folder and do not use any cached build')
    compile_parser.add_argument('--vid-pid', help='When specified, VID/PID specific build properties are used')
    compile_parser.add_argument('sketch', help='Path to sketch (file or directory)')

    # Upload command
    upload_parser = subparsers.add_parser('upload', help='Upload sketch to board')
    upload_parser.add_argument('-b', '--fqbn', required=True, help='Fully qualified board name')
    upload_parser.add_argument('-p', '--port', required=True, help='Serial port or device identifier')
    upload_parser.add_argument('--build-path', help='Directory containing build artifacts')
    upload_parser.add_argument('--verify', action='store_true', help='Verify after upload')
    upload_parser.add_argument('sketch', help='Path to sketch (file or directory)')

    # Board commands
    board_parser = subparsers.add_parser('board', help='Board management')
    board_subparsers = board_parser.add_subparsers(dest='board_command')

    # board list
    board_list_parser = board_subparsers.add_parser('list', help='List boards')

    # board search
    board_search_parser = board_subparsers.add_parser('search', help='Search boards')
    board_search_parser.add_argument('query', help='Search query')

    # Parse arguments
    args = parser.parse_args()

    # Execute command
    cli = ArduinoCLI()

    try:
        if args.command == 'lib':
            if args.lib_command == 'install':
                if args.requirements:
                    return cli.lib_import(args.requirements)
                else:
                    # Parse library[@version]
                    if '@' in args.library:
                        name, version = args.library.split('@', 1)
                        return cli.lib_install(name, version, args.with_deps)
                    else:
                        return cli.lib_install(args.library, with_deps=args.with_deps)

            elif args.lib_command == 'uninstall':
                return cli.lib_uninstall(args.library)

            elif args.lib_command == 'list':
                return cli.lib_list(format=args.format, installed_only=not args.all)

            elif args.lib_command == 'search':
                return cli.lib_search(args.query)

            elif args.lib_command == 'upgrade':
                return cli.lib_upgrade(args.library)

            elif args.lib_command == 'export':
                return cli.lib_export(args.output)

        elif args.command == 'core':
            if args.core_command == 'install':
                return cli.core_install(args.platform)

            elif args.core_command == 'uninstall':
                return cli.core_uninstall(args.platform)

            elif args.core_command == 'list':
                return cli.core_list()

        elif args.command == 'board':
            if args.board_command == 'list':
                return cli.board_list()

            elif args.board_command == 'search':
                return cli.board_search(args.query)

        elif args.command == 'compile':
            return cli.compile_sketch(
                args.fqbn,
                args.sketch,
                build_path=args.build_path,
                build_cache_path=args.build_cache_path,
                config=args.config,
                verbose=args.verbose,
                export_binaries=args.export_binaries,
                warnings=args.warnings,
                optimize_for_debug=args.optimize_for_debug,
                build_properties=args.build_property,
                libraries=args.libraries,
                library_paths=args.library,
                clean=args.clean,
                vid_pid=args.vid_pid
            )

        elif args.command == 'upload':
            return cli.upload_sketch(args.fqbn, args.port, args.sketch, build_path=args.build_path, verify=args.verify)
        else:
            parser.print_help()
            return 1

    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        return 130

    except Exception as e:
        print(f"✗ Error: {str(e)}", file=sys.stderr)
        return 1

    return 0


if __name__ == '__main__':
    sys.exit(main())
