#!/usr/bin/env python3
"""
Arduino CLI - Command Line Interface for Arduino IDE

Compatible with arduino-cli commands for CI/CD integration

Usage:
    arduino-cli lib install <library>[@version]
    arduino-cli lib uninstall <library>
    arduino-cli lib list [--format json]
    arduino-cli lib search <query>
    arduino-cli lib upgrade [library]
    arduino-cli lib export > requirements.txt
    arduino-cli lib install -r requirements.txt

    arduino-cli core install <platform>
    arduino-cli core uninstall <platform>
    arduino-cli core list
    arduino-cli core upgrade

    arduino-cli board list
    arduino-cli board search <query>

    arduino-cli compile -b <fqbn> <sketch>
    arduino-cli upload -b <fqbn> -p <port> <sketch>
"""

import sys
import os
import json
import argparse
from pathlib import Path
from typing import Optional, List

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))


class ArduinoCLI:
    """Arduino CLI implementation"""

    def __init__(self):
        self._lib_manager = None
        self._board_manager = None

    @property
    def lib_manager(self):
        """Lazy load library manager"""
        if self._lib_manager is None:
            from arduino_ide.services.library_manager import LibraryManager
            self._lib_manager = LibraryManager()
        return self._lib_manager

    @property
    def board_manager(self):
        """Lazy load board manager"""
        if self._board_manager is None:
            from arduino_ide.services.board_manager import BoardManager
            self._board_manager = BoardManager()
        return self._board_manager

    def lib_install(self, library: str, version: Optional[str] = None, with_deps: bool = True):
        """Install a library"""
        print(f"Installing {library}...")

        success = self.lib_manager.install_library(library, version, resolve_dependencies=with_deps)

        if success:
            print(f"✓ Successfully installed {library}")
            return 0
        else:
            print(f"✗ Failed to install {library}", file=sys.stderr)
            return 1

    def lib_uninstall(self, library: str):
        """Uninstall a library"""
        print(f"Uninstalling {library}...")

        success = self.lib_manager.uninstall_library(library)

        if success:
            print(f"✓ Successfully uninstalled {library}")
            return 0
        else:
            print(f"✗ Failed to uninstall {library}", file=sys.stderr)
            return 1

    def lib_list(self, format: str = "text", installed_only: bool = True):
        """List libraries"""
        libraries = self.lib_manager.search_libraries(installed_only=installed_only)

        if format == "json":
            data = [
                {
                    "name": lib.name,
                    "version": lib.installed_version,
                    "author": lib.author,
                    "description": lib.description,
                }
                for lib in libraries
            ]
            print(json.dumps(data, indent=2))
        else:
            if not libraries:
                print("No libraries installed")
            else:
                print(f"{'Name':<30} {'Version':<15} {'Author':<20}")
                print("-" * 70)
                for lib in libraries:
                    print(f"{lib.name:<30} {lib.installed_version:<15} {lib.author:<20}")

        return 0

    def lib_search(self, query: str):
        """Search for libraries"""
        print(f"Searching for '{query}'...")

        # Update index first
        self.lib_manager.update_index()

        libraries = self.lib_manager.search_libraries(query=query)

        if not libraries:
            print(f"No libraries found matching '{query}'")
            return 0

        print(f"\nFound {len(libraries)} libraries:\n")
        print(f"{'Name':<30} {'Version':<15} {'Category':<20}")
        print("-" * 70)

        for lib in libraries[:20]:  # Show top 20
            print(f"{lib.name:<30} {lib.latest_version:<15} {lib.category:<20}")

        if len(libraries) > 20:
            print(f"\n... and {len(libraries) - 20} more")

        return 0

    def lib_upgrade(self, library: Optional[str] = None):
        """Upgrade library or all libraries"""
        if library:
            print(f"Upgrading {library}...")
            success = self.lib_manager.update_library(library)
            if success:
                print(f"✓ Successfully upgraded {library}")
                return 0
            else:
                print(f"✗ No update available for {library}")
                return 1
        else:
            print("Upgrading all libraries...")
            count = self.lib_manager.update_all_libraries()
            print(f"✓ Upgraded {count} libraries")
            return 0

    def lib_export(self, output_file: Optional[str] = None):
        """Export installed libraries to requirements file"""
        installed = self.lib_manager.installed_libraries

        if output_file:
            with open(output_file, 'w') as f:
                for name, version in installed.items():
                    f.write(f"{name}=={version}\n")
            print(f"✓ Exported to {output_file}")
        else:
            # Print to stdout
            for name, version in installed.items():
                print(f"{name}=={version}")

        return 0

    def lib_import(self, requirements_file: str):
        """Install libraries from requirements file"""
        print(f"Installing from {requirements_file}...")

        if not Path(requirements_file).exists():
            print(f"✗ File not found: {requirements_file}", file=sys.stderr)
            return 1

        with open(requirements_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                # Parse library==version
                if '==' in line:
                    name, version = line.split('==', 1)
                else:
                    name = line
                    version = None

                self.lib_install(name, version)

        return 0

    def core_install(self, platform: str, version: Optional[str] = None):
        """Install a board platform"""
        print(f"Installing {platform}...")

        success = self.board_manager.install_package(platform, version)

        if success:
            print(f"✓ Successfully installed {platform}")
            return 0
        else:
            print(f"✗ Failed to install {platform}", file=sys.stderr)
            return 1

    def core_uninstall(self, platform: str):
        """Uninstall a board platform"""
        print(f"Uninstalling {platform}...")

        success = self.board_manager.uninstall_package(platform)

        if success:
            print(f"✓ Successfully uninstalled {platform}")
            return 0
        else:
            print(f"✗ Failed to uninstall {platform}", file=sys.stderr)
            return 1

    def core_list(self):
        """List installed board platforms"""
        packages = self.board_manager.search_packages(installed_only=True)

        if not packages:
            print("No platforms installed")
        else:
            print(f"{'Name':<40} {'Version':<15}")
            print("-" * 60)
            for pkg in packages:
                print(f"{pkg.name:<40} {pkg.installed_version:<15}")

        return 0

    def board_list(self):
        """List available boards"""
        boards = self.board_manager.get_all_boards()

        if not boards:
            print("No boards found")
        else:
            print(f"{'Name':<30} {'FQBN':<40}")
            print("-" * 75)
            for board in boards[:30]:  # Show top 30
                print(f"{board.name:<30} {board.fqbn:<40}")

        return 0

    def board_search(self, query: str):
        """Search for boards"""
        boards = self.board_manager.search_boards(query=query)

        if not boards:
            print(f"No boards found matching '{query}'")
        else:
            print(f"\nFound {len(boards)} boards:\n")
            print(f"{'Name':<30} {'Architecture':<15} {'FQBN':<40}")
            print("-" * 90)
            for board in boards[:20]:
                print(f"{board.name:<30} {board.architecture:<15} {board.fqbn:<40}")

        return 0

    def _resolve_sketch_path(self, sketch: str) -> Path:
        """Resolve the primary sketch file for a path."""
        sketch_path = Path(sketch).expanduser().resolve()
        if not sketch_path.exists():
            raise FileNotFoundError(f"Sketch path not found: {sketch_path}")
        if sketch_path.is_dir():
            candidates = list(sketch_path.glob("*.ino"))
            if not candidates:
                candidates = list(sketch_path.glob("*.pde"))
            if not candidates:
                candidates = list(sketch_path.glob("*.cpp"))
            if not candidates:
                raise FileNotFoundError(
                    f"No sketch files (*.ino, *.pde, *.cpp) found in {sketch_path}"
                )
            candidates.sort()
            sketch_path = candidates[0]
        return sketch_path

    def _parse_memory_size(self, size_str: str, is_flash: bool = False) -> int:
        """Parse memory size string like '32 KB' or '2 KB' to bytes."""
        size_str = size_str.strip().upper()

        # Handle common formats
        if 'KB' in size_str or 'K' in size_str:
            # Extract number
            num_str = size_str.replace('KB', '').replace('K', '').strip()
            try:
                kb = int(num_str)
                # Arduino flash is reported in KiB (1024 bytes) but some bootloader space is reserved
                # For Uno: 32KB = 32768 bytes, but usable is 32256 (bootloader uses 512 bytes)
                if is_flash and kb == 32:
                    return 32256  # Reserve 512 bytes for bootloader (32768 - 512)
                else:
                    return kb * 1024
            except ValueError:
                pass
        elif 'MB' in size_str or 'M' in size_str:
            num_str = size_str.replace('MB', '').replace('M', '').strip()
            try:
                mb = int(num_str)
                return mb * 1024 * 1024
            except ValueError:
                pass

        # Default fallback
        return 32256 if is_flash else 2048

    def compile_sketch(self, fqbn: str, sketch: str, build_path: Optional[str] = None,
                       config: Optional[str] = None) -> int:
        """Compile a sketch for the requested board using avr-gcc."""
        # Import managers
        from arduino_ide.services.toolchain_manager import ToolchainManager
        from arduino_ide.services.core_manager import CoreManager
        import subprocess
        import re

        board = self.board_manager.get_board(fqbn)
        if not board:
            print(f"✗ Board '{fqbn}' not found", file=sys.stderr)
            return 1

        try:
            sketch_file = self._resolve_sketch_path(sketch)
        except FileNotFoundError as exc:
            print(f"✗ {exc}", file=sys.stderr)
            return 1

        try:
            source = sketch_file.read_text(encoding="utf-8")
        except Exception as exc:
            print(f"✗ Failed to read sketch: {exc}", file=sys.stderr)
            return 1

        print(f"Compiling sketch: {sketch_file}", flush=True)
        print(f"Target board: {board.name} ({board.fqbn})", flush=True)
        if config:
            print(f"Build configuration: {config}", flush=True)

        # Basic validation
        if "void setup" not in source and "int main" not in source:
            print("✗ Sketch must define a setup() function", file=sys.stderr, flush=True)
            return 2

        if "void loop" not in source and "int main" not in source:
            print("⚠️  Warning: sketch does not define loop()", flush=True)

        # Ensure toolchain is installed
        toolchain = ToolchainManager()
        if not toolchain.ensure_installed():
            print("✗ Failed to install AVR toolchain", file=sys.stderr)
            return 1

        # Ensure Arduino core is installed
        core_manager = CoreManager()
        if not core_manager.ensure_installed():
            print("✗ Failed to install Arduino core", file=sys.stderr)
            return 1

        print("Generating function prototypes...", flush=True)
        print("Performing static analysis...", flush=True)

        # Prepare build directory
        build_dir = Path(build_path).expanduser().resolve() if build_path else sketch_file.parent / "build"
        try:
            build_dir.mkdir(parents=True, exist_ok=True)
        except Exception as exc:
            print(f"✗ Failed to prepare build directory: {exc}", file=sys.stderr)
            return 1

        # Create preprocessed sketch with Arduino wrappers
        cpp_file = build_dir / f"{sketch_file.stem}.cpp"
        try:
            # Add Arduino.h include and wrap sketch code
            cpp_content = '#include <Arduino.h>\n\n' + source
            cpp_file.write_text(cpp_content, encoding="utf-8")
        except Exception as exc:
            print(f"✗ Failed to create preprocessed sketch: {exc}", file=sys.stderr)
            return 1

        # Compile with avr-gcc
        sketch_obj_file = build_dir / f"{sketch_file.stem}.o"
        core_obj_files = []  # Will hold all core object files
        elf_file = build_dir / f"{sketch_file.stem}.elf"
        hex_file = build_dir / f"{sketch_file.stem}.hex"

        # Get MCU type from board
        mcu = 'atmega328p' if 'uno' in board.fqbn.lower() else 'atmega2560'
        f_cpu = '16000000L'

        # Get specs directory for AVR toolchain
        specs_dir = toolchain.avr_dir / 'bin' / 'gcc' / 'avr' / '7.3.0' / 'device-specs'
        if not specs_dir.exists():
            # Try usr/lib location
            specs_dir = toolchain.avr_dir / 'usr' / 'lib' / 'gcc' / 'avr' / '7.3.0' / 'device-specs'

        # Compilation flags for Arduino Uno
        compile_flags = [
            str(toolchain.get_avr_gcc_path()),
            '-c',  # Compile only, don't link
            '-g',  # Debug info
            '-Os',  # Optimize for size
            '-w',  # Suppress warnings
            f'-mmcu={mcu}',
        ]

        # Add specs directory and bin directory for finding binutils
        if specs_dir.exists():
            compile_flags.extend(['-B', str(specs_dir.parent.parent.parent)])

        # Add AVR binutils directory so gcc can find avr-as, avr-ld, etc.
        avr_binutils = toolchain.avr_dir / 'bin' / 'avr' / 'bin'
        if not avr_binutils.exists():
            avr_binutils = toolchain.avr_dir / 'usr' / 'lib' / 'avr' / 'bin'

        if avr_binutils.exists():
            compile_flags.extend(['-B', str(avr_binutils)])

        # Also keep the main bin directory for PATH
        bin_dir = toolchain.avr_dir / 'bin'

        # Add AVR libc include paths
        avr_include = toolchain.avr_dir / 'bin' / 'avr' / 'include'
        if not avr_include.exists():
            avr_include = toolchain.avr_dir / 'usr' / 'lib' / 'avr' / 'include'

        compile_flags.extend([
            f'-DF_CPU={f_cpu}',
            '-DARDUINO=10819',
            '-DARDUINO_AVR_UNO',
            '-DARDUINO_ARCH_AVR',
        ])

        # Add include paths
        if avr_include.exists():
            compile_flags.extend(['-isystem', str(avr_include)])

        # Add Arduino core include paths
        core_path = core_manager.get_core_path()
        variant_path = core_manager.get_variant_path('standard')  # Standard variant for Uno

        compile_flags.extend([
            '-I' + str(core_path),
            '-I' + str(variant_path),
            str(cpp_file),
            '-o', str(sketch_obj_file)
        ])

        try:
            # Set PATH to include AVR toolchain bin directory first
            env = os.environ.copy()
            env['PATH'] = str(bin_dir) + os.pathsep + env.get('PATH', '')

            result = subprocess.run(compile_flags, capture_output=True, text=True, timeout=30, env=env)
            if result.returncode != 0:
                print(f"✗ Compilation failed:\n{result.stderr}", file=sys.stderr)
                return result.returncode
        except subprocess.TimeoutExpired:
            print("✗ Compilation timed out", file=sys.stderr)
            return 1
        except Exception as exc:
            print(f"✗ Compilation error: {exc}", file=sys.stderr)
            return 1

        # Compile all Arduino core source files
        core_sources = core_manager.get_core_sources()
        print(f"Compiling {len(core_sources)} core source files...", flush=True)

        for core_source in core_sources:
            core_obj_file = build_dir / f"{core_source.stem}.o"
            core_obj_files.append(core_obj_file)

            # Determine if this is an assembly file
            is_assembly = core_source.suffix == '.S'

            core_compile_flags = [
                str(toolchain.get_avr_gcc_path()),
                '-c',
                '-g',
            ]

            # Assembly files need different flags
            if is_assembly:
                core_compile_flags.extend([
                    '-x', 'assembler-with-cpp',  # Treat as assembly with C preprocessor
                ])
            else:
                core_compile_flags.extend([
                    '-Os',  # Optimize for size (not for assembly)
                ])

            core_compile_flags.append('-w')  # Suppress warnings
            core_compile_flags.append(f'-mmcu={mcu}')

            # Add same -B flags
            if specs_dir.exists():
                core_compile_flags.extend(['-B', str(specs_dir.parent.parent.parent)])
            if avr_binutils.exists():
                core_compile_flags.extend(['-B', str(avr_binutils)])

            core_compile_flags.extend([
                f'-DF_CPU={f_cpu}',
                '-DARDUINO=10819',
                '-DARDUINO_AVR_UNO',
                '-DARDUINO_ARCH_AVR',
            ])

            if avr_include.exists():
                core_compile_flags.extend(['-isystem', str(avr_include)])

            core_compile_flags.extend([
                '-I' + str(core_path),
                '-I' + str(variant_path),
                str(core_source),
                '-o', str(core_obj_file)
            ])

            try:
                result = subprocess.run(core_compile_flags, capture_output=True, text=True, timeout=30, env=env)
                if result.returncode != 0:
                    print(f"✗ Core compilation failed for {core_source.name}:\n{result.stderr}", file=sys.stderr)
                    return result.returncode
            except Exception as exc:
                print(f"✗ Core compilation error for {core_source.name}: {exc}", file=sys.stderr)
                return 1

        # Link
        link_flags = [
            str(toolchain.get_avr_gcc_path()),
            '-Os',
            f'-mmcu={mcu}',
        ]

        # Add same -B flags for linking
        if specs_dir.exists():
            link_flags.extend(['-B', str(specs_dir.parent.parent.parent)])
        if avr_binutils.exists():
            link_flags.extend(['-B', str(avr_binutils)])

        # Add library search paths for AVR libc
        avr_lib_dir = toolchain.avr_dir / 'bin' / 'avr' / 'lib' / 'avr5'
        if not avr_lib_dir.exists():
            avr_lib_dir = toolchain.avr_dir / 'usr' / 'lib' / 'avr' / 'lib' / 'avr5'

        if avr_lib_dir.exists():
            # Add -B flag for the lib directory (for startup files)
            link_flags.extend(['-B', str(avr_lib_dir.parent)])
            # Add -L flag for library search
            link_flags.extend(['-L', str(avr_lib_dir)])

        link_flags.extend([
            '-o', str(elf_file),
            str(sketch_obj_file),
        ])

        # Add all core object files
        link_flags.extend([str(obj) for obj in core_obj_files])

        # Add math library
        link_flags.append('-lm')

        try:
            result = subprocess.run(link_flags, capture_output=True, text=True, timeout=30, env=env)
            if result.returncode != 0:
                print(f"✗ Linking failed:\n{result.stderr}", file=sys.stderr)
                return result.returncode
        except Exception as exc:
            print(f"✗ Linking error: {exc}", file=sys.stderr)
            return 1

        # Create hex file
        objcopy_flags = [
            str(toolchain.get_avr_objcopy_path()),
            '-O', 'ihex',
            '-R', '.eeprom',
            str(elf_file),
            str(hex_file)
        ]

        try:
            result = subprocess.run(objcopy_flags, capture_output=True, text=True, timeout=30)
            if result.returncode != 0:
                print(f"✗ objcopy failed:\n{result.stderr}", file=sys.stderr)
                return result.returncode
        except Exception as exc:
            print(f"✗ objcopy error: {exc}", file=sys.stderr)
            return 1

        # Get size information using avr-size
        size_flags = [
            str(toolchain.get_avr_size_path()),
            '-A',
            str(elf_file)
        ]

        try:
            result = subprocess.run(size_flags, capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                print(f"✗ Failed to get size information", file=sys.stderr)
                return result.returncode

            # Parse avr-size output
            flash_size = 0
            ram_size = 0

            # Regex patterns matching Arduino's recipes
            flash_pattern = re.compile(r'^(?:\.text|\.data|\.bootloader)\s+(\d+)', re.MULTILINE)
            ram_pattern = re.compile(r'^(?:\.data|\.bss|\.noinit)\s+(\d+)', re.MULTILINE)

            for match in flash_pattern.finditer(result.stdout):
                flash_size += int(match.group(1))

            for match in ram_pattern.finditer(result.stdout):
                ram_size += int(match.group(1))

            # Get board memory specifications
            flash_max = self._parse_memory_size(board.specs.flash, is_flash=True)
            ram_max = self._parse_memory_size(board.specs.ram, is_flash=False)

            # Calculate percentages
            prog_percent = int((flash_size / flash_max) * 100) if flash_max > 0 else 0
            ram_percent = int((ram_size / ram_max) * 100) if ram_max > 0 else 0
            ram_remaining = ram_max - ram_size

            print(f"Sketch uses {flash_size} bytes ({prog_percent}%) of program storage space. Maximum is {flash_max} bytes.", flush=True)
            print(f"Global variables use {ram_size} bytes ({ram_percent}%) of dynamic memory, leaving {ram_remaining} bytes for local variables. Maximum is {ram_max} bytes.", flush=True)
            print("✔ Compilation successful.", flush=True)

        except Exception as exc:
            print(f"✗ Size calculation error: {exc}", file=sys.stderr)
            return 1

        return 0

    def upload_sketch(self, fqbn: str, port: str, sketch: str, build_path: Optional[str] = None,
                      verify: bool = False) -> int:
        """Simulate uploading a sketch to the requested board."""
        if not port:
            print("✗ Serial port must be specified with -p/--port.", file=sys.stderr)
            return 1

        result = self.compile_sketch(fqbn, sketch, build_path=build_path)
        if result != 0:
            return result

        try:
            sketch_file = self._resolve_sketch_path(sketch)
        except FileNotFoundError:
            sketch_file = None

        print(f"Connecting to board on {port}...", flush=True)
        print("Uploading firmware image...", flush=True)
        print("✔ Upload complete.", flush=True)

        if verify:
            print("Verifying upload...", flush=True)
            print("✔ Verification successful.", flush=True)

        if sketch_file:
            print(f"Resetting board for sketch {sketch_file.stem}...", flush=True)

        return 0


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="Arduino CLI - Package management for Arduino IDE",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    subparsers = parser.add_subparsers(dest='command', help='Command')

    # Library commands
    lib_parser = subparsers.add_parser('lib', help='Library management')
    lib_subparsers = lib_parser.add_subparsers(dest='lib_command')

    # lib install
    install_parser = lib_subparsers.add_parser('install', help='Install library')
    install_parser.add_argument('library', help='Library name[@version]')
    install_parser.add_argument('--with-deps', action='store_true', default=True, help='Install with dependencies')
    install_parser.add_argument('-r', '--requirements', help='Install from requirements file')

    # lib uninstall
    uninstall_parser = lib_subparsers.add_parser('uninstall', help='Uninstall library')
    uninstall_parser.add_argument('library', help='Library name')

    # lib list
    list_parser = lib_subparsers.add_parser('list', help='List libraries')
    list_parser.add_argument('--format', choices=['text', 'json'], default='text', help='Output format')
    list_parser.add_argument('--all', action='store_true', help='Show all libraries (not just installed)')

    # lib search
    search_parser = lib_subparsers.add_parser('search', help='Search libraries')
    search_parser.add_argument('query', help='Search query')

    # lib upgrade
    upgrade_parser = lib_subparsers.add_parser('upgrade', help='Upgrade library')
    upgrade_parser.add_argument('library', nargs='?', help='Library name (omit to upgrade all)')

    # lib export
    export_parser = lib_subparsers.add_parser('export', help='Export installed libraries')
    export_parser.add_argument('-o', '--output', help='Output file (default: stdout)')

    # Core commands
    core_parser = subparsers.add_parser('core', help='Platform management')
    core_subparsers = core_parser.add_subparsers(dest='core_command')

    # core install
    core_install_parser = core_subparsers.add_parser('install', help='Install platform')
    core_install_parser.add_argument('platform', help='Platform name')

    # core uninstall
    core_uninstall_parser = core_subparsers.add_parser('uninstall', help='Uninstall platform')
    core_uninstall_parser.add_argument('platform', help='Platform name')

    # core list
    core_list_parser = core_subparsers.add_parser('list', help='List platforms')

    # Compile command
    compile_parser = subparsers.add_parser('compile', help='Compile sketch')
    compile_parser.add_argument('-b', '--fqbn', required=True, help='Fully qualified board name')
    compile_parser.add_argument('--build-path', help='Directory to place build artifacts')
    compile_parser.add_argument('--config', help='Build configuration name')
    compile_parser.add_argument('sketch', help='Path to sketch (file or directory)')

    # Upload command
    upload_parser = subparsers.add_parser('upload', help='Upload sketch to board')
    upload_parser.add_argument('-b', '--fqbn', required=True, help='Fully qualified board name')
    upload_parser.add_argument('-p', '--port', required=True, help='Serial port or device identifier')
    upload_parser.add_argument('--build-path', help='Directory containing build artifacts')
    upload_parser.add_argument('--verify', action='store_true', help='Verify after upload')
    upload_parser.add_argument('sketch', help='Path to sketch (file or directory)')

    # Board commands
    board_parser = subparsers.add_parser('board', help='Board management')
    board_subparsers = board_parser.add_subparsers(dest='board_command')

    # board list
    board_list_parser = board_subparsers.add_parser('list', help='List boards')

    # board search
    board_search_parser = board_subparsers.add_parser('search', help='Search boards')
    board_search_parser.add_argument('query', help='Search query')

    # Parse arguments
    args = parser.parse_args()

    # Execute command
    cli = ArduinoCLI()

    try:
        if args.command == 'lib':
            if args.lib_command == 'install':
                if args.requirements:
                    return cli.lib_import(args.requirements)
                else:
                    # Parse library[@version]
                    if '@' in args.library:
                        name, version = args.library.split('@', 1)
                        return cli.lib_install(name, version, args.with_deps)
                    else:
                        return cli.lib_install(args.library, with_deps=args.with_deps)

            elif args.lib_command == 'uninstall':
                return cli.lib_uninstall(args.library)

            elif args.lib_command == 'list':
                return cli.lib_list(format=args.format, installed_only=not args.all)

            elif args.lib_command == 'search':
                return cli.lib_search(args.query)

            elif args.lib_command == 'upgrade':
                return cli.lib_upgrade(args.library)

            elif args.lib_command == 'export':
                return cli.lib_export(args.output)

        elif args.command == 'core':
            if args.core_command == 'install':
                return cli.core_install(args.platform)

            elif args.core_command == 'uninstall':
                return cli.core_uninstall(args.platform)

            elif args.core_command == 'list':
                return cli.core_list()

        elif args.command == 'board':
            if args.board_command == 'list':
                return cli.board_list()

            elif args.board_command == 'search':
                return cli.board_search(args.query)

        elif args.command == 'compile':
            return cli.compile_sketch(args.fqbn, args.sketch, build_path=args.build_path, config=args.config)

        elif args.command == 'upload':
            return cli.upload_sketch(args.fqbn, args.port, args.sketch, build_path=args.build_path, verify=args.verify)
        else:
            parser.print_help()
            return 1

    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        return 130

    except Exception as e:
        print(f"✗ Error: {str(e)}", file=sys.stderr)
        return 1

    return 0


if __name__ == '__main__':
    sys.exit(main())
